#include <immintrin.h>

/**
 * The function to optimise as part of the coursework.
 *
 * l0, l1, l2 and l3 record the amount of time spent in each loop
 * and should not be optimised out. :)
 *
 * Profiler?
 * Vectors/vectorisation
 * SSE2
 * inverse square root
 * intrinsics
 * pipelining
 * branching
 * ILP
 */

void compute() {
	// preponderation
	int i;
	int v = (N/4)*4;

	// packaged floats
	__m128 dmp_ = _mm_load_ps1(&dmp);
	__m128 dt_ = _mm_load_ps1(&dt);
	__m128 factor_ = _mm_mul_ps(dmp_, dt_);
	__m128 zero_ = _mm_setzero_ps();


	double t0, t1;

	// Loop 0.
	t0 = wtime();
    for (i = 0; i < v; i += 4) {
        _mm_store_ps(ax+i, zero_);
    }
    for (i = 0; i < v; i += 4) {
        _mm_store_ps(ay+i, zero_);
    }
    for (i = 0; i < v; i += 4) {
        _mm_store_ps(az+i, zero_);
    }
    for (; i < N; i++) {
        ax[i] = 0.0f;
        ay[i] = 0.0f;
        az[i] = 0.0f;
    }
	t1 = wtime();
	l0 += (t1 - t0);

    // Loop 1.
	t0 = wtime();
	{
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				float rx = x[j] - x[i];
				float ry = y[j] - y[i];
				float rz = z[j] - z[i];
				float r2 = rx*rx + ry*ry + rz*rz + eps;
				float r2inv = 1.0f / sqrt(r2);
				float r6inv = r2inv * r2inv * r2inv;
				float s = m[j] * r6inv;
				ax[i] += s * rx;
				ay[i] += s * ry;
				az[i] += s * rz;
			}
		}
	}
	t1 = wtime();
	l1 += (t1 - t0);

	// Loop 2.
	t0 = wtime();
    for (i = 0; i < v; i+=4) {
        __m128 ax_ = _mm_load_ps(ax+i);
        __m128 tx_ = _mm_mul_ps(factor_, ax_);
        __m128 vx_ = _mm_load_ps(vx+i);
        	   vx_ = _mm_add_ps(vx_, tx_);
        _mm_store_ps(vx+i, vx_);
    }
    for (i = 0; i < v; i+=4) {
        __m128 ay_ = _mm_load_ps(ay+i);
        __m128 ty_ = _mm_mul_ps(factor_, ay_);
        __m128 vy_ = _mm_load_ps(vy+i);
        	   vy_ = _mm_add_ps(vy_, ty_);
        _mm_store_ps(vy+i, vy_);
    }
    for (i = 0; i < v; i+=4) {
        __m128 az_ = _mm_load_ps(az+i);
        __m128 tz_ = _mm_mul_ps(factor_, az_);
        __m128 vz_ = _mm_load_ps(vz+i);
        	   vz_ = _mm_add_ps(vz_, tz_);
        _mm_store_ps(vz+i, vz_);
    }
	for (; i < N; i++) {
		vx[i] += dmp * (dt * ax[i]);
		vy[i] += dmp * (dt * ay[i]);
		vz[i] += dmp * (dt * az[i]);
	}
	t1 = wtime();
	l2 += (t1 - t0);

	// Loop 3.
	t0 = wtime();
	for (i = 0; i < v; i+=4) {
		__m128 x_ = _mm_load_ps(x+i);
		__m128 vx_ = _mm_load_ps(vx+i);
			   vx_ = _mm_mul_ps(dt_, vx_);
			   vx_ = _mm_add_ps(vx_, x_);
		_mm_store_ps(x+i, vx_);
	}
	for (i = 0; i < v; i+=4) {
		__m128 y_ = _mm_load_ps(y+i);
		__m128 vy_ = _mm_load_ps(vy+i);
			   vy_ = _mm_mul_ps(dt_, vy_);
			   vy_ = _mm_add_ps(vy_, y_);
		_mm_store_ps(y+i, vy_);
	}
	for (i = 0; i < v; i+=4) {
		__m128 z_ = _mm_load_ps(z+i);
		__m128 vz_ = _mm_load_ps(vz+i);
			   vz_ = _mm_mul_ps(dt_, vz_);
			   vz_ = _mm_add_ps(vz_, z_);
		_mm_store_ps(z+i, vz_);
	}
	for (; i < N; i++) {
		x[i] += dt * vx[i];
		y[i] += dt * vy[i];
		z[i] += dt * vz[i];
		if (x[i] >= 1.0f || x[i] <= -1.0f) vx[i] *= -1.0f;
		if (y[i] >= 1.0f || y[i] <= -1.0f) vy[i] *= -1.0f;
		if (z[i] >= 1.0f || z[i] <= -1.0f) vz[i] *= -1.0f;
	}

	t1 = wtime();
	l3 += (t1 - t0);

}
